--- 
name: tutorial-4
format: textile
title: Tutorial, Part 4
published: 2008-01-30
tags: ""
author: Dan Yoder
domain: dan.local
summary: ""
content: |-
  In Part 3, we added comments to our blog. This required us customizing both our models and our URI mapping file. Now we're going to add some CSS and JavaScript to our blog. In order to do that, we need to first add Rack's file loader to our default application. So let's open our @development.rb@ file in @configurations@ and see what we've got.
  
  <pre>
  module Blog
    module Configurations
      class Development < Default
        database :adapter => 'sqlite', :database => 'blog'
  
        reloadable [ Blog ]
  
        log :level => :debug
  
        host '127.0.0.1'
  
        port 3000
  
        handler ::Rack::Handler::Mongrel, :Host => host, :Port => port
        # handler ::Rack::Handler::WEBrick, :BindAddress => host, :Port => port
        # handler ::Rack::Handler::Thin, :Host => host, :Port => port
  
        application do
          use ::Rack::ShowExceptions
          run ::Waves::Dispatchers::Default.new
        end
      end
    end
  end
  </pre>
  
  As we pointed out earlier, the configuration is just Ruby code, just like Markaby, the URI mappings, and so on. It's all just Ruby. The part we're interested in at the moment is the @application@ parameter. Let's add Rack's static file serving to our application.
  
  <pre>
  application do
    use Rack::Static, :urls => [ '/css', '/javascript' ], :root => 'public'
    use Rack::ShowExceptions
    run Waves::Dispatchers::Default.new
  end
  </pre>
  
  So, just like that, we can serve up our CSS and JavaScript files from @public/css@ and @public/javascript@. Next, we should include them in our default layout. So we edit @default.rb@ in the @templates/layout@ directory.
  
  <pre>
  doctype :html4_strict
  
  html do
  
    head do
      title @title
      script :src => '/javascript/site.js', :type => 'text/javascript'
      link :href => '/css/site.css', :rel => 'stylesheet', :type => 'text/css'
    end
  
    body do
      layout_content
    end
  
  end
  </pre>
  
  Of course, we still haven't added the actually CSS or JavaScript files. Let's start by giving our blog a little bit of a Web 2.0 flavor using @site.css@.
  
  <pre>
  body { font-family: Verdana, Arial, sans-serif; background-color: white; }
  h1, h2, h3, p, label, li { margin-bottom: 20px; }
  </pre>
  
  Nothing fancy, but just enough to prove that we're really loading our CSS. 
  
  Finally, we've got to restart the server because we redefined our application parameter. Normally, Waves will automatically reload everything for us (a "true reload":/reloading, by the way). But there are some parameters (the database configuration is another) that require a restart to get picked up.
  
  Finally, we can refresh our browser and see our fancy new styles! And if you do a view source, you can confirm that, sure enough, we're now loading our stylesheet and our JavaScript.
  
  Before we move on to the JavaScript, let's do what they call "motivating our example." We're going to start by adding a nice edit link at the top of our blog entry page. Of course, the edit link shouldn't appear to just anybody, only to the author of blog. So we should also add a nice little login page, so that they author can log in and edit their blog.
  
  For the moment, however, we are going to ignore that complication, which will be dealt with in Part 5 of our tutorial (coming soon). We'll just add the link so that we have an easy way to get to our edit page. When we're done, we should have something like this in our @show.mab@ template for entries.
  
  <pre>
  layout :default, :title => @entry.title do
    a 'Show All Entries', :href => '/entries'
    a 'Edit This Entry', :href => "/entry/#{@entry.name}/editor"
    h1 @entry.title
    textile @entry.content
    h1 'Comments'
    view :comment, :add, :entry => @entry
    view :comment, :list, :comments => @entry.comments
  end
  </pre>
  
  So now we can easily edit an entry as well as add new ones. But we still don't have a way to delete them. So let's add a delete link, right? The problem is that REST style delete uses an HTTP DELETE, not just an ordinary link. Here's where our JavaScript will come in. First, though, let's add our link. Our @editor.mab@ file should now look something like this.
  
  <pre>
  layout :default, :title => 'Edit Entry' do
    form :action => "/entry/#{@entry.name}/", :method => 'POST' do
      # fake an HTTP PUT
      input :name => '_method', :type => 'hidden', :value => 'put'
      label 'Title'; br
      input :type => :text, :value => @entry.title, :name => 'entry.title'; br
      label 'Summary'; br
      textarea @entry.summary, :name => 'entry.summary', :rows => 10, :cols => 80; br
      label 'Content'; br
      textarea @entry.content, :name => 'entry.content', :rows => 20, :cols => 80; br
      input :type => :submit, :value => 'Save'
      a.delete 'Delete', :href => "/entry/#{@entry.name}"
    end
  end
  </pre>
  
  We've used Markaby's clever CSS convention to add the class 'delete' to our link. At the moment, the link will do nothing except show us the entry. But we're going to use a little "jQuery":http://jquery.com magic to quickly turn this into an HTTP DELETE instead of an ordinary GET.
  
  First, we need to include jQuery in our scripts. So we add a @script@ tag prior to loading our own @site.js@ file.
  
  <pre>
  script :src => 'http://jqueryjs.googlecode.com/files/jquery-1.2.2.min.js',
    :type => 'text/javascript'
  </pre>
  
  Next, in our @site.js@ file, we simply add the a click handler to our delete link that will send an HTTP DELETE instead of a GET. Thanks to jQuery, this is darn near trivial, complete with a confirmation.
  
  <pre>
  $(document).ready( function() {
    $('a.delete').click( function() {
      if ( confirm("Are you sure?") ) {
        var href = $(this).attr('href');
        $.ajax({ type: 'delete', url: href, 
          success: function() { window.location = '/entries'; }
        });
      }
      // this isn't really a link ...
      // so tell the browser we've handled it
      return false;
    });
  });
  </pre>
  
  So let's go ahead and see if it works. We'll try deleting our first entry.
  
  !/images/deleting-an-entry.png?size=medium!
  
  Voila! We should end up back at our listing page (@/entries@) just as we asked for in our jQuery handler.
  
  So there you have it. A REST style blog with a little bit of Ajax sprinkled in for fun. We've added custom models and a custom URI mapping. We've even customized our application using a Rack middleware component for serving static files.
  
  For help or more information, we have "support forums":http://groups.google.com/group/rubywaves, #waves at irc.freenode.net, "reference documentation":http://waves.rubyforge.org/, and the "Hang Ten blog":http://rubywaves.com/blog/hang-ten where we'll be announcing new tutorials, screencasts, and other Waves-related news. Also, keep an eye out on the "wiki":http://code.google.com/p/waves/wiki, where we encourage people to post their tricks and techniques for using Waves.
